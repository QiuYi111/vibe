#!/bin/bash

# ==============================================================================
# VIBE FLOW: Git-Native Autonomous Coding Engine
# Version: 5.0 (Git-Native Edition)
# Architecture: Worktree-based parallel development with AI-powered merge resolution
# ==============================================================================

# --- âš™ï¸ å…¨å±€é…ç½® ---
INDEX_FILE="project_index.xml"
PLAN_FILE="vibe_plan.json"
REPORT_FILE="vibe_report.md"
LOG_DIR=".vibe_logs"
MAX_RETRIES=3
MAX_CONTEXT_SIZE_KB=500
MAX_PARALLEL_AGENTS=${MAX_PARALLEL_AGENTS:-2}

# å¿½ç•¥åˆ—è¡¨
IGNORE_PATTERNS="**/*.lock,**/node_modules,**/dist,**/.git,**/.DS_Store,**/build,**/.pio,**/.env*,**/*.key,**/secrets.*,**/__pycache__"

# --- ğŸ¨ é¢œè‰²å®šä¹‰ ---
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# --- ğŸ¨ Banner Display ---
function show_banner() {
    # ANSI Colors
    local C_RESET='\033[0m'
    local C_PURPLE='\033[1;35m'
    local C_CYAN='\033[1;36m'
    local C_BLUE='\033[1;34m'
    local C_DARK='\033[1;30m'
    
    echo ""
    echo -e "${C_PURPLE}â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    ${C_CYAN}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—${C_RESET}"
    echo -e "${C_PURPLE}â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•    ${C_CYAN}â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘${C_RESET}"
    echo -e "${C_PURPLE}â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      ${C_CYAN}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘${C_RESET}"
    echo -e "${C_PURPLE}â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•      ${C_CYAN}â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘${C_RESET}"
    echo -e "${C_PURPLE} â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    ${C_CYAN}â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•${C_RESET}"
    echo -e "${C_PURPLE}  â•šâ•â•â•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•    ${C_CYAN}â•šâ•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•šâ•â•â•${C_RESET}"
    echo -e "${C_BLUE}           [ AI ARCHITECT ] â€¢ [ SLEEP MODE: ON ] â€¢ [ ğŸŒ™ zzz ]${C_RESET}"
    echo ""
}

# --- ğŸŒ³ Git Worktree Management (v5.0 Core Infrastructure) ---

# Create isolated worktree for a task
function create_task_worktree() {
    local task_id="$1"
    local branch_name="feat/task_${task_id}"
    local worktree_path=".vibe_worktrees/${task_id}"

    # Ensure worktree directory exists FIRST
    if ! mkdir -p ".vibe_worktrees"; then
        echo "Error: Failed to create .vibe_worktrees directory" >&2
        return 1
    fi

    # Remove existing worktree if it exists (cleanup from failed runs)
    if [[ -d "$worktree_path" ]]; then
        git worktree remove "$worktree_path" --force 2>/dev/null
    fi

    # Create branch and worktree
    if ! git worktree add -b "$branch_name" "$worktree_path" 2>/dev/null; then
        # Branch might already exist, try without -b
        if ! git worktree add "$worktree_path" "$branch_name" 2>/dev/null; then
            echo "Error: Failed to create worktree for $task_id" >&2
            return 1
        fi
    fi

    # Verify worktree was created successfully
    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree directory was not created: $worktree_path" >&2
        return 1
    fi

    # Get absolute path to avoid any cd confusion
    echo "$(pwd)/$worktree_path"
}

# Cleanup worktree after completion
function cleanup_task_worktree() {
    local task_id="$1"
    local worktree_path=".vibe_worktrees/${task_id}"
    
    if [[ -d "$worktree_path" ]]; then
        git worktree remove "$worktree_path" --force 2>/dev/null
    fi
}

# --- ğŸ” Review Agent (Linus-style code review + dynamic test generation) ---
function run_review_agent() {
    local task_id="$1"
    local task_name="$2"
    local worktree_path="$3"
    local domain="$4"
    local review_log="$LOG_DIR/review_${task_id}.log"
    local review_report="$LOG_DIR/review_report_${task_id}.md"
    local test_cmd_file="$LOG_DIR/test_cmd_${task_id}.txt"
    
    echo -e "${BLUE}ğŸ” [Review Agent] Analyzing task: $task_name${NC}"
    
    # Get changes in worktree
    local changes=$(cd "$worktree_path" && git diff HEAD~1 --stat 2>/dev/null || echo "No commits yet")
    local diff_content=$(cd "$worktree_path" && git diff HEAD~1 2>/dev/null || echo "No diff available")
    
    local review_prompt="
[ROLE] You are Linus Torvalds reviewing code for the Linux kernel.

[TASK] $task_name (ID: $task_id)
[DOMAIN] $domain
[WORKTREE] $worktree_path

[CHANGES]
$changes

[DIFF]
$diff_content

[REVIEW PHILOSOPHY]
1. **Good Taste**: Code should be simple and elegant. No special cases.
2. **Clarity Over Cleverness**: If it's not obvious, it's wrong.
3. **Never Break Userspace**: Don't introduce breaking changes.
4. **Resource Management**: Every allocation must have a clear deallocation path.
5. **Error Handling**: Handle errors explicitly. No silent failures.

[INSTRUCTIONS]
1. Review the code changes using the philosophy above
2. Determine the appropriate test command(s) for this domain and changes
3. Output your review in this format:

## Review Report
[Your brutally honest review. If it's good, say LGTM. If not, be specific about what's wrong.]

## Test Command
[Single line test command to run, e.g., 'npm test' or 'pytest tests/test_foo.py']

If no tests are needed: echo 'No tests required'
"
    
    cd "$worktree_path"
    claude --dangerously-skip-permissions -p "$review_prompt" > "$review_report" 2>> "$review_log"
    
    # Extract test command
    grep -A1 "## Test Command" "$review_report" | tail -n1 | tr -d '`' > "$test_cmd_file"
    
    # Run the test command
    local test_cmd=$(cat "$test_cmd_file")
    echo ">>> Running test: $test_cmd" >> "$review_log"
    
    if eval "$test_cmd" >> "$review_log" 2>&1; then
        echo "âœ… Tests passed" >> "$review_log"
        cd - > /dev/null
        return 0
    else
        echo "âŒ Tests failed" >> "$review_log"
        cd - > /dev/null
        return 1
    fi
}

# --- ğŸ”€ Merge Manager (Orchestrates branch integration) ---
function merge_manager() {
    local task_branches=("$@")
    
    echo -e "${BLUE}ğŸ”€ [Merge Manager] Integrating ${#task_branches[@]} branches...${NC}"
    
    for branch in "${task_branches[@]}"; do
        if git merge --no-edit "$branch" > /dev/null 2>&1; then
            echo -e "${GREEN}âœ… Merged $branch${NC}"
        else
            echo -e "${YELLOW}âš ï¸  Conflict detected in $branch. Starting Mediator...${NC}"
            run_mediator "$branch"
        fi
    done
}

# --- âš–ï¸ AI Mediator (Linus-style conflict resolution) ---
function run_mediator() {
    local conflicted_branch="$1"
    local conflict_files=$(git diff --name-only --diff-filter=U)
    local mediator_log="$LOG_DIR/mediator_${conflicted_branch}.log"
    
    # Generate conflict context
    local conflict_diff=$(git diff)
    
    local mediation_prompt="
[ROLE] You are Linus Torvalds mediating a merge conflict.

[PHILOSOPHY]
- Good code has no special cases
- When in doubt, choose simplicity
- Both sides might be wrong - don't be afraid to write a third solution
- Never sacrifice correctness for convenience

[CONFLICT]
Branch: $conflicted_branch
Files: $conflict_files

[DIFF WITH CONFLICT MARKERS]
$conflict_diff

[TASK]
Resolve the conflicts by:
1. Understanding the intent of both code paths
2. Applying good taste - choose the simpler, more elegant solution
3. If both are flawed, write a better third solution
4. Use your native file editing tools to resolve conflicts in each file
5. Stage the resolved files and complete the merge

Be decisive. This is your codebase now.
"
    
    # Run Claude Code in the main worktree to resolve conflicts
    claude --dangerously-skip-permissions -p "$mediation_prompt" > "$mediator_log" 2>&1
    
    # Check if resolved
    if git diff --name-only --diff-filter=U | grep -q .; then
        echo -e "${RED}âŒ Mediator failed to resolve conflicts. Manual intervention required.${NC}"
        exit 1
    fi
    
    # Complete merge
    git commit --no-edit
    echo -e "${GREEN}âœ… Conflicts resolved by AI Mediator${NC}"
}

# --- ğŸ§© Integration Phase: System Verification & Healing ---
function run_integration_phase() {
    local domain="$1"
    local log_file="$LOG_DIR/integration_system.log"
    
    echo -e "${BLUE}ğŸ§© [Integration] Starting System-Wide Verification...${NC}"
    echo ">>> Starting Integration Phase" > "$log_file"

    # 1. Determine global test command
    local test_cmd=""
    case "$domain" in
        HARDWARE) test_cmd="pio test -e native" ;;
        AI_ROBOT) test_cmd="pytest" ;; 
        WEB)      test_cmd="npm test" ;;
        PYTHON_GENERIC) test_cmd="pytest" ;;
        *)        test_cmd="echo 'No global test command detected'" ;;
    esac

    # 2. Run full regression test suite
    echo -e "${CYAN}   Running global test suite: $test_cmd${NC}"
    if eval "$test_cmd" >> "$log_file" 2>&1; then
        echo -e "${GREEN}âœ… System Integration Tests Passed.${NC}"
        return 0
    else
        echo -e "${RED}âŒ System Tests Failed. Activating System Healer...${NC}"
    fi

    # 3. System Healer (fix integration issues)
    # This Agent has global perspective to fix "Integration Hell"
    local retries=0
    local max_retries=2
    
    while [[ $retries -lt $max_retries ]]; do
        echo ">>> System Healer Attempt $((retries+1))" >> "$log_file"
        
        local error_log=$(tail -n 100 "$log_file")
        local prompt="
[ROLE] System Architect & Debugger

[CONTEXT] 
Multiple features were just merged into the main branch. 
Individual unit tests passed, but the GLOBAL system test failed.

[ERROR LOG]
$error_log

[INSTRUCTION]
1. Analyze the error. It is likely an API mismatch or side-effect between modules.
2. Fix the code in the current directory directly using your native file editing tools.
3. After fixing, commit your changes with: git commit -am 'System Healer: Fixed integration issue'
4. Explain what you fixed and why.

Apply Linus philosophy:
- Fix the root cause, not symptoms
- Prefer simple solutions over complex ones
- If multiple modules are wrong, fix them all
"
        
        # Let Claude fix code in main branch
        claude --dangerously-skip-permissions -p "$prompt" >> "$log_file" 2>&1
        
        # Retry test
        if eval "$test_cmd" >> "$log_file" 2>&1; then
            echo -e "${GREEN}âœ… System Healer fixed the integration issue!${NC}"
            return 0
        fi
        
        ((retries++))
    done

    echo -e "${RED}ğŸ’€ Critical: System Healer failed to fix integration issues. Manual check required.${NC}"
    return 1
}

# --- ğŸ§ CTO Review: Architectural Audit ---
function run_cto_review() {
    local start_hash="$1"
    local report_file="vibe_cto_report.md"
    
    echo -e "${BLUE}ğŸ§ [CTO] Conducting Final Architectural Review...${NC}"
    
    # Get total changes from this session
    local total_diff=$(git diff "$start_hash" HEAD --stat)
    local commit_log=$(git log "$start_hash..HEAD" --oneline)
    
    local prompt="
[ROLE] Chief Technology Officer (CTO)

[TASK]
Review the code changes made in this entire development session.

[SESSION COMMITS]
$commit_log

[CHANGES SUMMARY]
$total_diff

[REVIEW CRITERIA]
Identify any:
1. **Architectural inconsistencies** (e.g., mixed naming conventions, inconsistent patterns)
2. **Redundant code** introduced by parallel agents
3. **Potential security risks** in the new code
4. **API design issues** (breaking changes, poor interfaces)
5. **Code style violations** (inconsistent formatting, unclear naming)

[OUTPUT FORMAT]
Generate a Markdown report with:
- Executive Summary (1-2 sentences)
- Quality Score (1-10)
- Issues Found (list with severity: CRITICAL/HIGH/MEDIUM/LOW)
- Recommendations for follow-up work

Be honest. If the code is excellent, say so. If it needs work, be specific about what and why.
Use Linus Torvalds' standards: good taste, simplicity, clarity.
"
    
    claude --dangerously-skip-permissions -p "$prompt" > "$report_file"
    echo -e "${GREEN}ğŸ“ CTO Report generated: $report_file${NC}"
    
    # Display summary
    if [[ -f "$report_file" ]]; then
        echo -e "${CYAN}=== CTO Review Summary ===${NC}"
        head -n 10 "$report_file"
        echo -e "${CYAN}=== (Full report in $report_file) ===${NC}"
    fi
}

# --- ğŸ Python JSON Extractor ---
read -r -d '' JSON_EXTRACTOR << EOM
import sys, json, re

def extract_json(content):
    # 1. Try to find markdown code blocks first
    pattern = re.compile(r'\`\`\`(?:json)?\s*(\[.*?\])\s*\`\`\`', re.DOTALL)
    match = pattern.search(content)
    if match:
        return match.group(1)
    
    # 2. Fallback: Find the first '[' and the last ']'
    start = content.find('[')
    end = content.rfind(']')
    
    if start != -1 and end != -1 and end > start:
        return content[start:end+1]
    return None

try:
    if len(sys.argv) > 1:
        with open(sys.argv[1], 'r', encoding='utf-8') as f:
            content = f.read()
    else:
        content = sys.stdin.read()

    json_str = extract_json(content)
    
    if json_str:
        # Validate JSON
        obj = json.loads(json_str)
        print(json.dumps(obj, indent=2))
    else:
        print("Error: No JSON found", file=sys.stderr)
        sys.exit(1)

except Exception as e:
    print(f"Error: {str(e)}", file=sys.stderr)
    sys.exit(1)
EOM

# --- ğŸ” ä¾èµ–æ£€æŸ¥ ---
function check_deps() {
    local deps=("claude" "jq" "git" "node" "npx" "python3")
    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            echo -e "${RED}âŒ Critical Error: Missing dependency '$cmd'. Please install it.${NC}"
            exit 1
        fi
    done
    mkdir -p "$LOG_DIR"
}

# --- ğŸ§  é¢†åŸŸä¸æ¨¡å¼æ¢æµ‹ ---
function detect_domain() {
    if [[ -f "platformio.ini" || -f "CMakeLists.txt" ]]; then echo "HARDWARE"; return; fi
    if [[ -f "mamba_env.yaml" || -d "src/ros2" ]]; then echo "AI_ROBOT"; return; fi
    if ls *.py > /dev/null 2>&1; then echo "PYTHON_GENERIC"; return; fi
    if [[ -f "package.json" || -f "next.config.js" ]]; then echo "WEB"; return; fi
    echo "GENERIC"
}

function detect_mode() {
    if [[ ! -d ".git" ]]; then echo "SCRATCH"; return; fi
    if [[ ! -f "$INDEX_FILE" ]]; then echo "INIT_INDEX"; return; fi
    echo "MAINTAIN"
}

# --- ğŸ› ï¸ JSON æå–å·¥å…· ---
function extract_json_block() {
    local input_file="$1"
    python3 -c "$JSON_EXTRACTOR" "$input_file"
}

# --- ğŸ“š Core: Librarian ---
function run_librarian() {
    local mode="$1"
    echo -e "${BLUE}ğŸ“š [Librarian] Analyzing context...${NC}"

    # Context Size Check
    if [[ -f "raw_context.xml" ]]; then
        local size_kb=$(du -k "raw_context.xml" | cut -f1)
        if [[ "$size_kb" -gt "$MAX_CONTEXT_SIZE_KB" ]]; then
            echo -e "${YELLOW}âš ï¸ Warning: Context size ($size_kb KB) is large. Truncation may occur.${NC}"
        fi
    fi

    # Incremental Check
    if [[ "$mode" == "MAINTAIN" ]]; then
        local last_hash=$(sed -nE 's/.*<!-- COMMIT: (.*) -->.*/\1/p' "$INDEX_FILE")
        local current_hash=$(git rev-parse HEAD)
        if [[ "$last_hash" == "$current_hash" ]]; then
            echo -e "${GREEN}âœ… Index is up-to-date.${NC}"
            return
        fi
    fi

    # Repomix Execution
    echo -e "${YELLOW}âš¡ Extracting codebase (Repomix)...${NC}"
    if ! npx repomix --style xml --ignore "$IGNORE_PATTERNS" --output raw_context.xml > /dev/null 2>&1; then
        echo -e "${RED}âŒ Repomix failed. Check npx/network.${NC}"
        exit 1
    fi

    # LLM Index Generation
    local prompt="/sc:index-repo
    You are a Senior Architect. Convert raw context to a 'Semantic Index'.
    Output ONLY valid XML.
    Include: <tech_stack>, <project_structure>, <api_signatures>, <dependency_graph>.
    NO actual code logic.
    Last line must be: <!-- COMMIT: $(git rev-parse HEAD 2>/dev/null || echo 'INIT') -->
    "
    cat raw_context.xml | claude --dangerously-skip-permissions -p "$prompt" > "$INDEX_FILE"
}

# --- ğŸ—ï¸ Core: Architect ---
function run_architect() {
    echo -e "${BLUE}ğŸ—ï¸  [Architect] Planning tasks...${NC}"
    local reqs=$(cat REQUIREMENTS.md 2>/dev/null || echo "Optimize existing codebase based on index.")
    local index=$(cat "$INDEX_FILE")
    local domain=$(detect_domain)

    local base_prompt="/sc:estimate
    [Context]
    Domain: $domain
    $index
    
    [Requirements]
    $reqs
    
    [Task]
    Break down requirements into parallelizable tasks.
    Constraint: The system can run at most $MAX_PARALLEL_AGENTS parallel agents.
    IMPORTANT: Ensure tasks modify DIFFERENT files to avoid race conditions.
    NOTE: Tasks will be executed in batches of $MAX_PARALLEL_AGENTS. Design tasks to be independent within batches.
    
    [Output Format]
    RETURN ONLY A RAW JSON ARRAY. 
    Wrap the JSON in a markdown code block like this:
    \`\`\`json
    [ ... ]
    \`\`\`
    DO NOT include any explanation or text outside the code block.
    
    SCHEMA DEFINITION:
    - \"id\": string (unique task id)
    - \"name\": string (short task name)  <-- MUST use \"name\", NOT \"title\"
    - \"desc\": string (detailed description) <-- MUST use \"desc\", NOT \"description\"

    Example:
    [{\"id\": \"task_1\", \"name\": \"Auth\", \"desc\": \"Implement login\"}]
    "

    local retry_count=0
    local max_retries=3
    local success=false

    while [ $retry_count -lt $max_retries ]; do
        if [ $retry_count -eq 0 ]; then
            claude --dangerously-skip-permissions -p "$base_prompt" > raw_plan_output.txt
        else
            echo -e "${YELLOW}âš ï¸ JSON Parse Error. Retrying ($retry_count/$max_retries)...${NC}"
            local error_msg=$(jq -e . raw_plan.json 2>&1)
            local fix_prompt="
            [System]
            The previous JSON output was invalid.
            Error: $error_msg
            
            [Previous Output]
            $(cat raw_plan_output.txt)
            
            [Instruction]
            Fix the JSON syntax. Output ONLY the valid JSON array.
            REMINDER: Use \"name\" and \"desc\" fields.
            "
            claude --dangerously-skip-permissions -p "$fix_prompt" > raw_plan_output.txt
        fi

        extract_json_block "raw_plan_output.txt" > raw_plan.json
        
        if jq -e . raw_plan.json > "$PLAN_FILE"; then
            echo -e "${GREEN}âœ… Plan generated: $(jq '. | length' "$PLAN_FILE") tasks.${NC}"
            rm raw_plan_output.txt raw_plan.json
            success=true
            break
        else
            ((retry_count++))
        fi
    done

    if [ "$success" = false ]; then
        echo -e "${RED}âŒ Architect failed to generate valid JSON after $max_retries retries.${NC}"
        exit 1
    fi
}

# --- ğŸš€ Core: Factory (The Pipeline) ---
function run_agent_pipeline() {
    local id="$1"
    local name="$2"
    local desc="$3"
    local domain=$(detect_domain)
    local log_file="$LOG_DIR/${id}.log"
    local branch_name="feat/task_${id}"
    
    echo -e "${CYAN}ğŸš€ [Agent] $name (Worktree: $branch_name)${NC}"

    (
        # Create isolated worktree
        local worktree_path=$(create_task_worktree "$id")
        
        if [[ -z "$worktree_path" ]]; then
            echo "âŒ Failed to create worktree" >> "$log_file"
            exit 1
        fi
        
        # Initial build prompt (NO custom delimiters, NO hardcoded tests)
        local build_prompt="/sc:implement
[INDEX] $(cat $INDEX_FILE)
[TASK] $desc
[WORKTREE] $worktree_path
[DOMAIN] $domain

[INSTRUCTIONS]
1. You are working in an isolated Git worktree at: $worktree_path
2. FIRST, ensure .gitignore includes: node_modules/, venv/, __pycache__/, *.pyc, dist/, build/, .env
3. Use your native file editing tools to implement the task
4. Install dependencies if needed (npm install, pip install, etc.)
5. When complete, commit your changes: git commit -am 'Agent: $name - Initial implementation'
6. Use existing dependencies if available to save time
"
        
        # Execute Claude Code in worktree
        echo ">>> Agent working in $worktree_path..." > "$log_file"
        cd "$worktree_path"
        
        # Self-healing loop with Review Agent
        local retries=0
        local review_feedback=""
        
        while [[ $retries -lt $MAX_RETRIES ]]; do
            # Build or heal
            if [[ $retries -eq 0 ]]; then
                claude --dangerously-skip-permissions -p "$build_prompt" >> "$log_file" 2>&1
            else
                # Healing with review feedback
                local heal_prompt="
[PREVIOUS COMMIT] $(git log --oneline -1)
[REVIEW FEEDBACK]
$review_feedback

[INSTRUCTION]
Fix the issues identified in the review. Then commit: git commit -am 'Agent: $name - Fix attempt $retries'
"
                claude --dangerously-skip-permissions -p "$heal_prompt" >> "$log_file" 2>&1
            fi
            
            # Check if agent committed
            if ! git log --oneline -1 2>/dev/null | grep -q "Agent: $name"; then
                echo "âš ï¸ Agent did not commit, retrying..." >> "$log_file"
                ((retries++))
                continue
            fi
            
            cd - > /dev/null
            
            # Run Review Agent
            if run_review_agent "$id" "$name" "$worktree_path" "$domain"; then
                echo "âœ… Implementation passed review and tests" >> "$log_file"
                break
            else
                # Extract review feedback for next iteration
                review_feedback=$(cat "$LOG_DIR/review_report_${id}.md")
                echo "âš ï¸ Review failed, healing ($((retries+1))/$MAX_RETRIES)..." >> "$log_file"
                ((retries++))
                cd "$worktree_path"
            fi
        done
        
        if [[ $retries -ge $MAX_RETRIES ]]; then
            echo "âŒ Task failed after $MAX_RETRIES attempts" >> "$log_file"
            cd - > /dev/null
            exit 1
        fi
        
    ) &
    PIDS+=($!)
    TASK_BRANCHES+=("$branch_name")
}

# --- ğŸ“Š Dashboard ---
function monitor_progress() {
    local pids=("$@")
    local spinners=("â ‹" "â ™" "â ¹" "â ¸" "â ¼" "â ´" "â ¦" "â §" "â ‡" "â ")
    local spin_idx=0
    
    while true; do
        local running=0
        for pid in "${pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                ((running++))
            fi
        done
        
        if [[ $running -eq 0 ]]; then
            break
        fi
        
        # Get latest log activity
        local latest_log=$(ls -t "$LOG_DIR"/*.log 2>/dev/null | head -n 1)
        local activity=""
        if [[ -f "$latest_log" ]]; then
            activity=$(tail -n 1 "$latest_log" | cut -c 1-50)
        fi
        
        printf "\r${BLUE}%s Active: %d/%d | Last: %s...${NC}   " "${spinners[spin_idx]}" "$running" "$MAX_PARALLEL_AGENTS" "$activity"
        
        spin_idx=$(( (spin_idx + 1) % 10 ))
        sleep 0.5
    done
    echo ""
}

# ================= ğŸ¬ Execution =================

# --- â“ Help Command ---
function show_help() {
    echo ""
    echo -e "${BLUE}Usage:${NC}"
    echo -e "  vibe [options]"
    echo ""
    echo -e "${BLUE}Options:${NC}"
    echo -e "  ${GREEN}--help, -h${NC}       Show this help message"
    echo ""
    echo -e "${BLUE}Environment Variables:${NC}"
    echo -e "  ${GREEN}MAX_PARALLEL_AGENTS${NC}  Number of concurrent agents (default: 2)"
    echo -e "  ${GREEN}MAX_RETRIES${NC}          Max retries for agent tasks (default: 3)"
    echo ""
    echo -e "${BLUE}Examples:${NC}"
    echo -e "  vibe"
    echo -e "  MAX_PARALLEL_AGENTS=4 vibe"
    echo ""
}

# Check for help flag
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    show_banner
    show_help
    exit 0
fi

show_banner
check_deps

MODE=$(detect_mode)
DOMAIN=$(detect_domain)

echo -e "${CYAN}Mode: $MODE | Domain: $DOMAIN${NC}"
echo ""

# Init
if [[ "$MODE" == "SCRATCH" ]]; then
    git init
    if [[ ! -f "REQUIREMENTS.md" ]]; then
        echo "# $DOMAIN Requirements" > REQUIREMENTS.md
        echo -e "${RED}âš ï¸  REQUIREMENTS.md created. Please edit it then re-run.${NC}"
        exit 0
    fi
fi

# --- ğŸŒ¿ Branch Management ---
if ! git show-ref --verify --quiet refs/heads/vibe; then
    echo -e "${BLUE}ğŸŒ¿ Creating 'vibe' branch...${NC}"
    git checkout -b vibe
else
    echo -e "${BLUE}ğŸŒ¿ Switching to 'vibe' branch...${NC}"
    git checkout vibe
fi

# Record starting state for CTO Review comparison
START_HASH=$(git rev-parse HEAD 2>/dev/null || echo "EMPTY_TREE")
if [[ "$START_HASH" == "EMPTY_TREE" ]]; then
    # Empty repository - create initial commit
    git commit --allow-empty -m "Initial commit for Vibe Flow session" > /dev/null 2>&1
    START_HASH=$(git rev-parse HEAD)
fi
echo -e "${CYAN}ğŸ“ Session starting at commit: ${START_HASH:0:8}${NC}"

run_librarian "$MODE"
run_architect

# Parallel Execution with Worktrees
declare -a PIDS
declare -a TASK_BRANCHES
TASK_COUNT=$(jq '. | length' "$PLAN_FILE")

# Ensure worktree directory exists
mkdir -p .vibe_worktrees

echo -e "${BLUE}âš¡ Launching $TASK_COUNT tasks with worktrees (Max Parallel: $MAX_PARALLEL_AGENTS)...${NC}"

# Launch tasks with parallelism control
for ((i=0; i<TASK_COUNT; i++)); do
    t_id=$(jq -r ".[$i].id" "$PLAN_FILE")
    t_name=$(jq -r ".[$i].name" "$PLAN_FILE")
    t_desc=$(jq -r ".[$i].desc" "$PLAN_FILE")
    
    run_agent_pipeline "$t_id" "$t_name" "$t_desc"
    
    # Rate limiting: wait after every MAX_PARALLEL_AGENTS tasks
    if (( (i + 1) % MAX_PARALLEL_AGENTS == 0 )); then
        echo -e "${YELLOW}â³ Waiting for batch to complete...${NC}"
        monitor_progress "${PIDS[@]}"
        PIDS=()
    fi
done

# Wait for remaining tasks
if [[ ${#PIDS[@]} -gt 0 ]]; then
    echo -e "${YELLOW}â³ Waiting for final batch...${NC}"
    monitor_progress "${PIDS[@]}"
fi

# Merge all task branches
merge_manager "${TASK_BRANCHES[@]}"

# Cleanup worktrees
echo -e "${BLUE}ğŸ§¹ Cleaning up worktrees...${NC}"
for ((i=0; i<TASK_COUNT; i++)); do
    t_id=$(jq -r ".[$i].id" "$PLAN_FILE")
    cleanup_task_worktree "$t_id"
done

# ==========================================
# ğŸ§© Integration Phase (Team Feedback)
# ==========================================
echo ""
echo -e "${YELLOW}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${YELLOW}   INTEGRATION & QUALITY ASSURANCE${NC}"
echo -e "${YELLOW}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

# Run system-wide integration tests with healing
if ! run_integration_phase "$DOMAIN"; then
    echo -e "${RED}âš ï¸  Integration phase encountered issues. Check logs.${NC}"
    # Don't exit - CTO review might still provide value
fi

# Run CTO architectural review
run_cto_review "$START_HASH"

# Final Report
echo ""
echo -e "${BLUE}ğŸ›¡ï¸  Generating Session Report...${NC}"
git status > git_status.txt
report_prompt="Summarize session. Input: $(cat \"$PLAN_FILE\"), Git: $(cat git_status.txt), Logs: .vibe_logs/*.md"
claude --dangerously-skip-permissions -p "$report_prompt" > "$REPORT_FILE"

run_librarian "MAINTAIN"
echo ""
echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${GREEN}ğŸ‰ Vibe Flow v5.0 Session Complete!${NC}"
echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${CYAN}ğŸ“Š Session Report: $REPORT_FILE${NC}"
echo -e "${CYAN}ğŸ§ CTO Review: vibe_cto_report.md${NC}"
echo -e "${CYAN}ğŸ“ Logs: $LOG_DIR/${NC}"