#!/bin/bash

# ==============================================================================
# VIBE FLOW: Git-Native Autonomous Coding Engine
# Version: 5.0 (Git-Native Edition)
# Architecture: Worktree-based parallel development with AI-powered merge resolution
# ==============================================================================

# --- ‚öôÔ∏è ÂÖ®Â±ÄÈÖçÁΩÆ ---
INDEX_FILE="project_index.xml"
PLAN_FILE="vibe_plan.json"
REPORT_FILE="vibe_report.md"
LOG_DIR=".vibe_logs"
MAX_RETRIES=3
MAX_CONTEXT_SIZE_KB=500  # ÈôêÂà∂ Context Â§ßÂ∞èÔºåÈò≤Ê≠¢ API Êä•Èîô
MAX_PARALLEL_AGENTS=${MAX_PARALLEL_AGENTS:-2} # Default to 2, configurable via env
AUTO_COMMIT=${AUTO_COMMIT:-false}  # Set AUTO_COMMIT=true to enable auto-commit

# ÂøΩÁï•ÂàóË°® (Security Hardened)
IGNORE_PATTERNS="**/*.lock,**/node_modules,**/dist,**/.git,**/.DS_Store,**/build,**/.pio,**/.env*,**/*.key,**/secrets.*,**/__pycache__"

# --- üé® È¢úËâ≤ÂÆö‰πâ ---
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# --- üå≥ Git Worktree Management (v5.0 Core Infrastructure) ---

# Create isolated worktree for a task
function create_task_worktree() {
    local task_id="$1"
    local branch_name="feat/task_${task_id}"
    local worktree_path=".vibe_worktrees/${task_id}"
    
    # Ensure worktree directory exists
    mkdir -p .vibe_worktrees
    
    # Create branch and worktree
    if ! git worktree add -b "$branch_name" "$worktree_path" 2>/dev/null; then
        # Branch might already exist, try without -b
        git worktree add "$worktree_path" "$branch_name" 2>/dev/null || {
            echo "Error: Failed to create worktree for $task_id"
            return 1
        }
    fi
    
    echo "$worktree_path"
}

# Cleanup worktree after completion
function cleanup_task_worktree() {
    local task_id="$1"
    local worktree_path=".vibe_worktrees/${task_id}"
    
    if [[ -d "$worktree_path" ]]; then
        git worktree remove "$worktree_path" --force 2>/dev/null
    fi
}

# --- üîç Review Agent (Linus-style code review + dynamic test generation) ---
function run_review_agent() {
    local task_id="$1"
    local task_name="$2"
    local worktree_path="$3"
    local domain="$4"
    local review_log="$LOG_DIR/review_${task_id}.log"
    local review_report="$LOG_DIR/review_report_${task_id}.md"
    local test_cmd_file="$LOG_DIR/test_cmd_${task_id}.txt"
    
    echo -e "${BLUE}üîç [Review Agent] Analyzing task: $task_name${NC}"
    
    # Get changes in worktree
    local changes=$(cd "$worktree_path" && git diff HEAD~1 --stat 2>/dev/null || echo "No commits yet")
    local diff_content=$(cd "$worktree_path" && git diff HEAD~1 2>/dev/null || echo "No diff available")
    
    local review_prompt="
[ROLE] You are Linus Torvalds reviewing code for the Linux kernel.

[TASK] $task_name (ID: $task_id)
[DOMAIN] $domain
[WORKTREE] $worktree_path

[CHANGES]
$changes

[DIFF]
$diff_content

[REVIEW PHILOSOPHY]
1. **Good Taste**: Code should be simple and elegant. No special cases.
2. **Clarity Over Cleverness**: If it's not obvious, it's wrong.
3. **Never Break Userspace**: Don't introduce breaking changes.
4. **Resource Management**: Every allocation must have a clear deallocation path.
5. **Error Handling**: Handle errors explicitly. No silent failures.

[INSTRUCTIONS]
1. Review the code changes using the philosophy above
2. Determine the appropriate test command(s) for this domain and changes
3. Output your review in this format:

## Review Report
[Your brutally honest review. If it's good, say LGTM. If not, be specific about what's wrong.]

## Test Command
[Single line test command to run, e.g., 'npm test' or 'pytest tests/test_foo.py']

If no tests are needed: echo 'No tests required'
"
    
    cd "$worktree_path"
    claude --dangerously-skip-permissions -p "$review_prompt" > "$review_report" 2>> "$review_log"
    
    # Extract test command
    grep -A1 "## Test Command" "$review_report" | tail -n1 | tr -d '`' > "$test_cmd_file"
    
    # Run the test command
    local test_cmd=$(cat "$test_cmd_file")
    echo ">>> Running test: $test_cmd" >> "$review_log"
    
    if eval "$test_cmd" >> "$review_log" 2>&1; then
        echo "‚úÖ Tests passed" >> "$review_log"
        cd - > /dev/null
        return 0
    else
        echo "‚ùå Tests failed" >> "$review_log"
        cd - > /dev/null
        return 1
    fi
}

# --- üîÄ Merge Manager (Orchestrates branch integration) ---
function merge_manager() {
    local task_branches=("$@")
    
    echo -e "${BLUE}üîÄ [Merge Manager] Integrating ${#task_branches[@]} branches...${NC}"
    
    for branch in "${task_branches[@]}"; do
        if git merge --no-edit "$branch" > /dev/null 2>&1; then
            echo -e "${GREEN}‚úÖ Merged $branch${NC}"
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Conflict detected in $branch. Starting Mediator...${NC}"
            run_mediator "$branch"
        fi
    done
}

# --- ‚öñÔ∏è AI Mediator (Linus-style conflict resolution) ---
function run_mediator() {
    local conflicted_branch="$1"
    local conflict_files=$(git diff --name-only --diff-filter=U)
    local mediator_log="$LOG_DIR/mediator_${conflicted_branch}.log"
    
    # Generate conflict context
    local conflict_diff=$(git diff)
    
    local mediation_prompt="
[ROLE] You are Linus Torvalds mediating a merge conflict.

[PHILOSOPHY]
- Good code has no special cases
- When in doubt, choose simplicity
- Both sides might be wrong - don't be afraid to write a third solution
- Never sacrifice correctness for convenience

[CONFLICT]
Branch: $conflicted_branch
Files: $conflict_files

[DIFF WITH CONFLICT MARKERS]
$conflict_diff

[TASK]
Resolve the conflicts by:
1. Understanding the intent of both code paths
2. Applying good taste - choose the simpler, more elegant solution
3. If both are flawed, write a better third solution
4. Use your native file editing tools to resolve conflicts in each file
5. Stage the resolved files and complete the merge

Be decisive. This is your codebase now.
"
    
    # Run Claude Code in the main worktree to resolve conflicts
    claude --dangerously-skip-permissions -p "$mediation_prompt" > "$mediator_log" 2>&1
    
    # Check if resolved
    if git diff --name-only --diff-filter=U | grep -q .; then
        echo -e "${RED}‚ùå Mediator failed to resolve conflicts. Manual intervention required.${NC}"
        exit 1
    fi
    
    # Complete merge
    git commit --no-edit
    echo -e "${GREEN}‚úÖ Conflicts resolved by AI Mediator${NC}"
}

# --- üêç Python JSON Extractor (New: Robust JSON Parsing) ---
read -r -d '' JSON_EXTRACTOR << EOM
import sys, json, re

def extract_json(content):
    # 1. Try to find markdown code blocks first
    pattern = re.compile(r'\`\`\`(?:json)?\s*(\[.*?\])\s*\`\`\`', re.DOTALL)
    match = pattern.search(content)
    if match:
        return match.group(1)
    
    # 2. Fallback: Find the first '[' and the last ']'
    start = content.find('[')
    end = content.rfind(']')
    
    if start != -1 and end != -1 and end > start:
        return content[start:end+1]
    return None

try:
    if len(sys.argv) > 1:
        with open(sys.argv[1], 'r', encoding='utf-8') as f:
            content = f.read()
    else:
        content = sys.stdin.read()

    json_str = extract_json(content)
    
    if json_str:
        # Validate JSON
        obj = json.loads(json_str)
        print(json.dumps(obj, indent=2))
    else:
        print("Error: No JSON found", file=sys.stderr)
        sys.exit(1)

except Exception as e:
    print(f"Error: {str(e)}", file=sys.stderr)
    sys.exit(1)
EOM

# --- üîç ‰æùËµñÊ£ÄÊü• ---
function check_deps() {
    local deps=("claude" "jq" "git" "node" "npx" "python3")
    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            echo -e "${RED}‚ùå Critical Error: Missing dependency '$cmd'. Please install it.${NC}"
            exit 1
        fi
    done
    mkdir -p "$LOG_DIR"
}

# --- üß† È¢ÜÂüü‰∏éÊ®°ÂºèÊé¢Êµã ---
function detect_domain() {
    if [[ -f "platformio.ini" || -f "CMakeLists.txt" ]]; then echo "HARDWARE"; return; fi
    if [[ -f "mamba_env.yaml" || -d "src/ros2" ]]; then echo "AI_ROBOT"; return; fi
    if ls *.py >/dev/null 2>&1; then echo "PYTHON_GENERIC"; return; fi
    if [[ -f "package.json" || -f "next.config.js" ]]; then echo "WEB"; return; fi
    echo "GENERIC"
}

function detect_mode() {
    if [[ ! -d ".git" ]]; then echo "SCRATCH"; return; fi
    if [[ ! -f "$INDEX_FILE" ]]; then echo "INIT_INDEX"; return; fi
    echo "MAINTAIN"
}

# --- üîç Git-Based Change Detection: Static Checks ---
function run_static_checks() {
    local domain="$1"
    local changed_files="$2"
    local log_file="$3"
    
    echo ">>> Running static checks..." >> "$log_file"
    
    case "$domain" in
        WEB)
            # ESLint for JS/TS files
            if command -v eslint &> /dev/null; then
                while IFS= read -r line; do
                    local status=$(echo "$line" | awk '{print $1}')
                    local file=$(echo "$line" | awk '{print $2}')
                    [[ ! "$status" =~ ^[AMD]$ ]] && continue
                    
                    if [[ "$file" =~ \.(ts|tsx|js|jsx)$ ]]; then
                        if ! eslint "$file" >> "$log_file" 2>&1; then
                            echo "‚ùå ESLint failed for $file" >> "$log_file"
                            return 1
                        fi
                    fi
                done < "$changed_files"
            fi
            
            # TypeScript type checking
            if [[ -f "tsconfig.json" ]] && command -v tsc &> /dev/null; then
                if ! tsc --noEmit >> "$log_file" 2>&1; then
                    echo "‚ùå TypeScript check failed" >> "$log_file"
                    return 1
                fi
            fi
            ;;
            
        PYTHON_GENERIC|AI_ROBOT)
            # Pylint for Python files
            if command -v pylint &> /dev/null; then
                while IFS= read -r line; do
                    local status=$(echo "$line" | awk '{print $1}')
                    local file=$(echo "$line" | awk '{print $2}')
                    [[ ! "$status" =~ ^[AMD]$ ]] && continue
                    
                    if [[ "$file" =~ \.py$ ]]; then
                        # Use --exit-zero to get warnings without failing
                        pylint --exit-zero "$file" >> "$log_file" 2>&1
                    fi
                done < "$changed_files"
            fi
            ;;
            
        HARDWARE)
            # PlatformIO static analysis
            if [[ -f "platformio.ini" ]] && command -v pio &> /dev/null; then
                if ! pio check >> "$log_file" 2>&1; then
                    echo "‚ùå PlatformIO check failed" >> "$log_file"
                    return 1
                fi
            fi
            ;;
    esac
    
    echo "‚úÖ Static checks passed" >> "$log_file"
    return 0
}

# --- üîç Git-Based Change Detection: Code Review ---
function run_code_review() {
    local task_name="$1"
    local task_id="$2"
    local changed_files="$3"
    local log_file="$4"
    local review_file="$LOG_DIR/review_${task_id}.md"
    
    echo ">>> Running code review (Claude as Linus)..." >> "$log_file"
    
    # Generate diff for changed files only
    local diff_content=""
    while IFS= read -r line; do
        local status=$(echo "$line" | awk '{print $1}')
        local file=$(echo "$line" | awk '{print $2}')
        [[ ! "$status" =~ ^[AMD]$ ]] && continue
        
        if [[ "$status" == "A" ]]; then
            # New file: show full content (limit to 100 lines)
            diff_content+="=== NEW FILE: $file ===\n"
            diff_content+="$(head -n 100 "$file" 2>/dev/null || echo '[Binary or missing]')\n\n"
        else
            # Modified: show diff
            diff_content+="$(git diff HEAD "$file" 2>/dev/null | head -n 100)\n\n"
        fi
    done < "$changed_files"
    
    # Truncate if too large (safety check)
    diff_content=$(echo -e "$diff_content" | head -c 10000)
    
    local review_prompt="
[ROLE] You are Linus Torvalds reviewing a code submission for the Linux kernel.

[TASK] $task_name (ID: $task_id)

[CHANGES]
$diff_content

[REVIEW CRITERIA]
1. **Logic Correctness**: Any obvious bugs or flawed logic?
2. **Edge Cases**: Null checks, boundary conditions (0, negative, empty arrays)?
3. **Resource Management**: Memory leaks, unclosed files/connections?
4. **Error Handling**: Proper exception handling?
5. **Code Taste**: Is this 'good taste' code? (Simple, clear, no special cases)

[OUTPUT FORMAT]
If APPROVED:
LGTM: [brief reason, 1 sentence]

If REJECTED:
REJECT: [critical issues, be specific]
SUGGESTIONS:
- [specific fix, be actionable]
"
    
    # Run review
    if ! claude --dangerously-skip-permissions -p "$review_prompt" > "$review_file" 2>&1; then
        echo "‚ö†Ô∏è Code review API failed, skipping..." >> "$log_file"
        return 0  # Don't fail the pipeline on review API errors
    fi
    
    # Check result
    if grep -q "^LGTM:" "$review_file"; then
        echo "‚úÖ Code review passed: $(grep '^LGTM:' "$review_file")" >> "$log_file"
        return 0
    else
        echo "‚ùå Code review REJECTED:" >> "$log_file"
        cat "$review_file" >> "$log_file"
        return 1
    fi
}

# --- üîß Enhanced Healer with Git Context ---
function run_healer() {
    local failure_type="$1"  # "static_check" | "unit_test" | "code_review"
    local log_file="$2"
    local changed_files="$3"
    local write_instruction="$4"
    
    echo ">>> Healer activated (Failure: $failure_type)..." >> "$log_file"
    
    # Extract error context
    local error_context=$(tail -n 50 "$log_file")
    
    # Get diff of current changes
    local current_diff=""
    if [[ -s "$changed_files" ]]; then
        while IFS= read -r line; do
            local status=$(echo "$line" | awk '{print $1}')
            local file=$(echo "$line" | awk '{print $2}')
            [[ ! "$status" =~ ^[AMD]$ ]] && continue
            
            current_diff+="=== $file ===\n"
            current_diff+="$(git diff HEAD "$file" 2>/dev/null | head -n 100)\n\n"
        done < "$changed_files"
    fi
    
    # Truncate diff if too large
    current_diff=$(echo -e "$current_diff" | head -c 8000)
    
    local heal_prompt="
[ROLE] Code Healer - Fix $failure_type failure

[FAILURE TYPE] $failure_type

[ERROR CONTEXT]
$error_context

[CURRENT CHANGES (Git Diff)]
$current_diff

[INSTRUCTION]
Analyze the error and the diff. Provide a targeted fix.
Focus on the specific failure type.

$write_instruction
"
    
    # Run healer
    claude --dangerously-skip-permissions -p "$heal_prompt" >> "$log_file" 2>&1
    
    # Apply fixes
    python3 -c "$PYTHON_PATCHER" "$log_file" >> "$log_file" 2>&1
    
    # Check if healer made changes
    if grep -q "NO_CHANGES_FOUND" "$log_file"; then
        echo "‚ÑπÔ∏è Healer could not generate a fix." >> "$log_file"
        return 1
    fi
    
    return 0
}

# --- üõ†Ô∏è JSON ÊèêÂèñÂ∑•ÂÖ∑ (Â¢ûÂº∫ÂÅ•Â£ÆÊÄß) ---
function extract_json_block() {
    local input_file="$1"
    python3 -c "$JSON_EXTRACTOR" "$input_file"
}

# --- üìö Core: Librarian ---
function run_librarian() {
    local mode="$1"
    echo -e "${BLUE}üìö [Librarian] Analyzing context...${NC}"

    # Context Size Check
    if [[ -f "raw_context.xml" ]]; then
        local size_kb=$(du -k "raw_context.xml" | cut -f1)
        if [[ "$size_kb" -gt "$MAX_CONTEXT_SIZE_KB" ]]; then
            echo -e "${YELLOW}‚ö†Ô∏è Warning: Context size ($size_kb KB) is large. Truncation may occur.${NC}"
        fi
    fi

    # Incremental Check
    if [[ "$mode" == "MAINTAIN" ]]; then
        local last_hash=$(sed -nE 's/.*<!-- COMMIT: (.*) -->.*/\1/p' "$INDEX_FILE")
        local current_hash=$(git rev-parse HEAD)
        if [[ "$last_hash" == "$current_hash" ]]; then
            echo -e "${GREEN}‚úÖ Index is up-to-date.${NC}"
            return
        fi
    fi

    # Repomix Execution
    echo -e "${YELLOW}‚ö° Extracting codebase (Repomix)...${NC}"
    if ! npx repomix --style xml --ignore "$IGNORE_PATTERNS" --output raw_context.xml > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Repomix failed. Check npx/network.${NC}"
        exit 1
    fi

    # LLM Index Generation
    local prompt="/sc:index-repo
    You are a Senior Architect. Convert raw context to a 'Semantic Index'.
    Output ONLY valid XML.
    Include: <tech_stack>, <project_structure>, <api_signatures>, <dependency_graph>.
    NO actual code logic.
    Last line must be: <!-- COMMIT: $(git rev-parse HEAD 2>/dev/null || echo 'INIT') -->
    "
    cat raw_context.xml | claude --dangerously-skip-permissions -p "$prompt" > "$INDEX_FILE"
}

# --- üèóÔ∏è Core: Architect ---
function run_architect() {
    echo -e "${BLUE}üèóÔ∏è  [Architect] Planning tasks...${NC}"
    local reqs=$(cat REQUIREMENTS.md 2>/dev/null || echo "Optimize existing codebase based on index.")
    local index=$(cat "$INDEX_FILE")
    local domain=$(detect_domain)

    # Âü∫Á°Ä Prompt
    local base_prompt="/sc:estimate
    [Context]
    Domain: $domain
    $index
    
    [Requirements]
    $reqs
    
    [Task]
    Break down requirements into parallelizable tasks.
    Constraint: The system can run at most $MAX_PARALLEL_AGENTS parallel agents.
    IMPORTANT: Ensure tasks modify DIFFERENT files to avoid race conditions.
    NOTE: Tasks will be executed in batches of $MAX_PARALLEL_AGENTS. Design tasks to be independent within batches.
    
    [Output Format]
    RETURN ONLY A RAW JSON ARRAY. 
    Wrap the JSON in a markdown code block like this:
    \`\`\`json
    [ ... ]
    \`\`\`
    DO NOT include any explanation or text outside the code block.
    
    SCHEMA DEFINITION:
    - \"id\": string (unique task id)
    - \"name\": string (short task name)  <-- MUST use \"name\", NOT \"title\"
    - \"desc\": string (detailed description) <-- MUST use \"desc\", NOT \"description\"

    Example:
    [{\"id\": \"task_1\", \"name\": \"Auth\", \"desc\": \"Implement login\"}]
    "

    local retry_count=0
    local max_retries=3
    local success=false

    while [ $retry_count -lt $max_retries ]; do
        if [ $retry_count -eq 0 ]; then
            # È¶ñÊ¨°Â∞ùËØï
            claude --dangerously-skip-permissions -p "$base_prompt" > raw_plan_output.txt
        else
            # ÈáçËØïÈÄªËæëÔºöÂ∞ÜÈîôËØØÂèçÈ¶àÁªô LLM
            echo -e "${YELLOW}‚ö†Ô∏è JSON Parse Error. Retrying ($retry_count/$max_retries)...${NC}"
            local error_msg=$(jq -e . raw_plan.json 2>&1)
            local fix_prompt="
            [System]
            The previous JSON output was invalid.
            Error: $error_msg
            
            [Previous Output]
            $(cat raw_plan_output.txt)
            
            [Instruction]
            Fix the JSON syntax. Output ONLY the valid JSON array.
            REMINDER: Use \"name\" and \"desc\" fields.
            "
            claude --dangerously-skip-permissions -p "$fix_prompt" > raw_plan_output.txt
        fi

        # Â∞ùËØïÊèêÂèñÂíåËß£Êûê
        extract_json_block "raw_plan_output.txt" > raw_plan.json
        
        if jq -e . raw_plan.json > "$PLAN_FILE"; then
            echo -e "${GREEN}‚úÖ Plan generated: $(jq '. | length' "$PLAN_FILE") tasks.${NC}"
            rm raw_plan_output.txt raw_plan.json
            success=true
            break
        else
            ((retry_count++))
        fi
    done

    if [ "$success" = false ]; then
        echo -e "${RED}‚ùå Architect failed to generate valid JSON after $max_retries retries.${NC}"
        echo -e "${RED}Debug: See raw_plan_output.txt${NC}"
        exit 1
    fi
}

# --- üöÄ Core: Factory (The Pipeline) ---
function run_agent_pipeline() {
    local id="$1"
    local name="$2"
    local desc="$3"
    local domain=$(detect_domain)
    local log_file="$LOG_DIR/${id}.log"
    
    echo -e "${CYAN}üöÄ [Agent] $name ($domain)${NC}"

    (
        # ========== NEW: Pre-Snapshot (Git State Before) ==========
        local pre_snapshot="$LOG_DIR/${id}_pre.snapshot"
        local post_snapshot="$LOG_DIR/${id}_post.snapshot"
        local changed_files="$LOG_DIR/${id}_changes.txt"
        
        echo ">>> Capturing pre-build Git state..." > "$log_file"
        git diff --name-status > "$pre_snapshot" 2>/dev/null
        git ls-files --others --exclude-standard >> "$pre_snapshot" 2>/dev/null
        
        # --- 1. Builder Phase ---
        local test_cmd="echo 'No test command defined'"
        
        # Domain Logic
        case "$domain" in
            HARDWARE) test_cmd="pio test -e native" ;;
            AI_ROBOT) test_cmd="pytest" ;; # Assumes pytest is configured
            WEB)      test_cmd="npm test" ;;
            PYTHON_GENERIC) test_cmd="pytest" ;;
            *)        test_cmd="echo 'GENERIC: Verify manually'" ;;
        esac

        # üî¥ CRITICAL: Instruction for Write-Back
        # We force the LLM to use delimiters that our Python Patcher can parse.
        local write_instruction="
        CRITICAL OUTPUT FORMAT:
        To write code, you MUST use the following custom format exactly.
        DO NOT wrap the content in markdown code blocks (like \`\`\`python ... \`\`\`).
        
        Format:
        <<<<FILE: path/to/file.ext>>>>
        [File content goes here]
        <<<<END>>>>
        
        You can output multiple files. Any text outside these tags is treated as comments.
        "

        local build_prompt="/sc:implement
        [INDEX] $(cat $INDEX_FILE)
        [TASK] $desc
        $write_instruction
        "
        
        echo ">>> Building..." >> "$log_file"
        # Run Claude with retries
        local api_retries=0
        local api_success=false
        while [[ $api_retries -lt 3 ]]; do
            if claude --dangerously-skip-permissions -p "$build_prompt" >> "$log_file" 2>&1; then
                api_success=true
                break
            else
                echo "‚ö†Ô∏è API Error (Attempt $((api_retries+1))/3)" >> "$log_file"
                sleep 2
                ((api_retries++))
            fi
        done

        if [[ "$api_success" == "false" ]]; then
             echo "‚ùå CRITICAL API FAILURE" >> "$log_file"
             exit 1
        fi

        # Apply Changes (Write-Back) - Keep for backward compatibility
        echo ">>> Applying changes..." >> "$log_file"
        python3 -c "$PYTHON_PATCHER" "$log_file" >> "$log_file" 2>&1
        
        # ========== NEW: Post-Snapshot & Change Detection ==========
        echo ">>> Detecting Git changes..." >> "$log_file"
        git diff --name-status > "$post_snapshot" 2>/dev/null
        git ls-files --others --exclude-standard >> "$post_snapshot" 2>/dev/null
        
        # Compute actual changes
        comm -3 <(sort "$pre_snapshot") <(sort "$post_snapshot") > "$changed_files"
        
        # Filter to only show A/M/D status lines
        grep -E '^[AMD]' "$changed_files" > "${changed_files}.tmp" 2>/dev/null && mv "${changed_files}.tmp" "$changed_files"
        
        # Check if changes were actually made (Git-based detection)
        if [[ ! -s "$changed_files" ]]; then
            echo "‚ÑπÔ∏è No file changes detected (Git-based). Task classified as Analysis." >> "$log_file"
            exit 0
        fi
        
        echo "üìù Detected changes:" >> "$log_file"
        cat "$changed_files" >> "$log_file"

        # --- 2. Enhanced Verifier & Healer Loop ---
        local retries=0
        local max_heal_attempts=$MAX_RETRIES
        local overall_success=false
        
        while [[ $retries -lt $max_heal_attempts ]]; do
            echo ">>> Verification Cycle $((retries+1))..." >> "$log_file"
            local cycle_success=true
            
            # Phase A: Static Checks
            if ! run_static_checks "$domain" "$changed_files" "$log_file"; then
                echo "‚ö†Ô∏è Static checks failed (Attempt $((retries+1))). Healing..." >> "$log_file"
                if ! run_healer "static_check" "$log_file" "$changed_files" "$write_instruction"; then
                    echo "‚ö†Ô∏è Healer could not fix static check issues." >> "$log_file"
                    cycle_success=false
                    ((retries++))
                    continue
                fi
                cycle_success=false
            fi
            
            # Phase B: Unit Tests (only if static checks passed)
            if [[ "$cycle_success" == "true" ]]; then
                echo ">>> Test Run $((retries+1)) ($test_cmd)..." >> "$log_file"
                
                local cmd_bin=$(echo "$test_cmd" | awk '{print $1}')
                if ! command -v "$cmd_bin" &> /dev/null && [[ "$cmd_bin" != "echo" ]]; then
                    echo "‚ö†Ô∏è Test command '$cmd_bin' not found. Skipping unit tests." >> "$log_file"
                else
                    if ! eval "$test_cmd" >> "$log_file" 2>&1; then
                        echo "‚ö†Ô∏è Unit tests failed (Attempt $((retries+1))). Healing..." >> "$log_file"
                        if ! run_healer "unit_test" "$log_file" "$changed_files" "$write_instruction"; then
                            echo "‚ö†Ô∏è Healer could not fix test failures." >> "$log_file"
                            cycle_success=false
                            ((retries++))
                            continue
                        fi
                        cycle_success=false
                    fi
                fi
            fi
            
            # Phase C: Code Review (only if tests passed)
            if [[ "$cycle_success" == "true" ]]; then
                if ! run_code_review "$name" "$id" "$changed_files" "$log_file"; then
                    echo "‚ö†Ô∏è Code review failed (Attempt $((retries+1))). Healing..." >> "$log_file"
                    if ! run_healer "code_review" "$log_file" "$changed_files" "$write_instruction"; then
                        echo "‚ö†Ô∏è Healer could not address review concerns." >> "$log_file"
                        cycle_success=false
                        ((retries++))
                        continue
                    fi
                    cycle_success=false
                fi
            fi
            
            # Check if all phases passed
            if [[ "$cycle_success" == "true" ]]; then
                echo "‚úÖ All verifications passed (Static + Tests + Review)" >> "$log_file"
                overall_success=true
                break
            fi
            
            # Update snapshots for next iteration (healer changed files)
            git diff --name-status > "$post_snapshot" 2>/dev/null
            git ls-files --others --exclude-standard >> "$post_snapshot" 2>/dev/null
            comm -3 <(sort "$pre_snapshot") <(sort "$post_snapshot") > "$changed_files"
            grep -E '^[AMD]' "$changed_files" > "${changed_files}.tmp" 2>/dev/null && mv "${changed_files}.tmp" "$changed_files"
            
            ((retries++))
        done

        if [[ "$overall_success" == "false" ]]; then
            echo "‚ùå Module failed after $max_heal_attempts healing attempts." >> "$log_file"
            exit 1
        fi

        # --- 3. Auto Commit (Optional) ---
        if [[ "$AUTO_COMMIT" == "true" && "$overall_success" == "true" ]]; then
            echo ">>> Auto-committing changes..." >> "$log_file"
            
            # Stage changed files
            while IFS= read -r line; do
                local status=$(echo "$line" | awk '{print $1}')
                local file=$(echo "$line" | awk '{print $2}')
                [[ ! "$status" =~ ^[AMD]$ ]] && continue
                git add "$file" 2>> "$log_file"
            done < "$changed_files"
            
            # Commit
            if git diff --cached --quiet; then
                echo "‚ÑπÔ∏è No changes to commit" >> "$log_file"
            else
                git commit -m "Agent: $name - Auto-commit after verification" >> "$log_file" 2>&1
                echo "‚úÖ Changes committed" >> "$log_file"
            fi
        fi

    ) & 
    PIDS+=($!)
}

# --- üìä Dashboard ---
function monitor_progress() {
    local pids=("$@")
    local spinners=("‚†ã" "‚†ô" "‚†π" "‚†∏" "‚†º" "‚†¥" "‚†¶" "‚†ß" "‚†á" "‚†è")
    local spin_idx=0
    
    while true; do
        local running=0
        for pid in "${pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                ((running++))
            fi
        done
        
        if [[ $running -eq 0 ]]; then
            break
        fi
        
        # Get latest log activity
        local latest_log=$(ls -t "$LOG_DIR"/*.log 2>/dev/null | head -n 1)
        local activity=""
        if [[ -f "$latest_log" ]]; then
            activity=$(tail -n 1 "$latest_log" | cut -c 1-50)
        fi
        
        # Display status with failure reason
        local status_msg=""
        if [[ -f "$latest_log" ]]; then
             # Check for specific errors
             if grep -q "CRITICAL API FAILURE" "$latest_log"; then
                 status_msg="${RED}API Failed${NC}"
             elif grep -q "NO_CHANGES_FOUND" "$latest_log"; then
                 status_msg="${BLUE}No Changes${NC}"
             elif grep -q "Test Failed" "$latest_log"; then
                 status_msg="${YELLOW}Healing...${NC}"
             else
                 status_msg=$(tail -n 1 "$latest_log" | cut -c 1-40)
             fi
        fi
        
        printf "\r${BLUE}%s Active: %d/%d | %s | Last: %s...${NC}   " "${spinners[spin_idx]}" "$running" "$MAX_PARALLEL_AGENTS" "$status_msg" "$activity"
        
        spin_idx=$(( (spin_idx + 1) % 10 ))
        sleep 0.5
    done
    echo "" # New line after done
}

# ================= üé¨ Execution =================

check_deps

MODE=$(detect_mode)
DOMAIN=$(detect_domain)

echo -e "${YELLOW}üî• VibeFlow v4.0 | Mode: $MODE | Domain: $DOMAIN | Balance: (Check Web UI)${NC}"

# Init
if [[ "$MODE" == "SCRATCH" ]]; then
    git init
    if [[ ! -f "REQUIREMENTS.md" ]]; then
        echo "# $DOMAIN Requirements" > REQUIREMENTS.md
        echo -e "${RED}‚ö†Ô∏è  REQUIREMENTS.md created. Please edit it then re-run.${NC}"
        exit 0
    fi
fi

# --- üåø Branch Management ---
# Ensure we are on 'vibe' branch to protect main/master
if ! git show-ref --verify --quiet refs/heads/vibe; then
    echo -e "${BLUE}üåø Creating 'vibe' branch...${NC}"
    git checkout -b vibe
else
    echo -e "${BLUE}üåø Switching to 'vibe' branch...${NC}"
    git checkout vibe
fi

run_librarian "$MODE"
run_architect

# Parallel Execution (Batch Mode)
declare -a PIDS
TASK_COUNT=$(jq '. | length' "$PLAN_FILE")

# Calculate batches
TOTAL_BATCHES=$(( (TASK_COUNT + MAX_PARALLEL_AGENTS - 1) / MAX_PARALLEL_AGENTS ))
echo -e "${BLUE}‚ö° Queued $TASK_COUNT tasks in $TOTAL_BATCHES batches (Max Parallel: $MAX_PARALLEL_AGENTS)...${NC}"

for ((b=0; b<$TOTAL_BATCHES; b++)); do
    BATCH_START=$((b * MAX_PARALLEL_AGENTS))
    BATCH_END=$((BATCH_START + MAX_PARALLEL_AGENTS))
    if [ $BATCH_END -gt $TASK_COUNT ]; then BATCH_END=$TASK_COUNT; fi
    
    echo -e "${CYAN}üì¶ Starting Batch $((b+1))/$TOTAL_BATCHES (Tasks $((BATCH_START+1)) to $BATCH_END)...${NC}"
    
    # Clear PIDS for this batch
    PIDS=()
    
    for ((i=$BATCH_START; i<$BATCH_END; i++)); do
        t_id=$(jq -r ".[$i].id" "$PLAN_FILE")
        t_name=$(jq -r ".[$i].name" "$PLAN_FILE")
        t_desc=$(jq -r ".[$i].desc" "$PLAN_FILE")
        
        run_agent_pipeline "$t_id" "$t_name" "$t_desc"
        sleep 1
    done
    
    # Wait for ALL in this batch
    echo -e "${YELLOW}‚è≥ Waiting for batch $((b+1)) to complete...${NC}"
    monitor_progress "${PIDS[@]}"
done

# Report
echo -e "${BLUE}üõ°Ô∏è  Generating Report...${NC}"
git status > git_status.txt
report_prompt="Summarize session. Input: $(cat "$PLAN_FILE"), Git: $(cat git_status.txt), Logs: .vibe_logs/*.md"
claude --dangerously-skip-permissions -p "$report_prompt" > "$REPORT_FILE"

run_librarian "MAINTAIN"
echo -e "${GREEN}üéâ Done. Report: $REPORT_FILE${NC}"